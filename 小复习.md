## 阻止默认事件

        传统的事件绑定用return false就能阻止浏览器默认行为。
        
        如果事件绑定，那么用ev.preventDefault()就能阻止浏览器默认行为。
        
        在低版本IE下使用事件绑定，用return false就能阻止浏览器默认行为。

## 阻止冒泡

        阻止冒泡：在传统的事件绑定中，直接ev.cancelBubble = true就可以阻止。
        		
        ev.cancelBubble并不是标准，但是所有浏览器都兼容类似children
        		
        标准的是ev.stopPropagation()，但是低版本IE不兼容。
    		
        事件绑定：
        
            标准下用ev.stopPropagation()  也可以用 ev.cancelBubble = true
        			
            低版本IE用ev.cancelBubble = true
        
### ajax是什么? ajax的交互模型? 同步和异步的区别? 如何解决跨域问题? 
		
		异步的js与xml {} [] ''
		
		ajax:
		
			Asynchronous JavaScript and XML
			
			前端与后端进行数据交互的一种技术。（通过这个技术能够拿到后端的数据接口）
			
			ajax中如果没有做过处理，都是字符串（只不过有些数据长的像json）
			
			
			ajax的优点：
				传输获取数据，不用跳转页面，在本页面请求服务器，做到实时验证。
				减少用户，返工率并且优化用户体验。
				
			
			同步：
			
				false的时候，send方法必须等到服务器处理完才执行后面的代码。
				
			异步：
				
				true的时候，send方法会立马返回，这样，可以执行后面的代码。
				
			
			跨域？
				1.jsonp跨域   √
				
					*数据必须是回调函数*  
				
				2.flash
				
				3.iframe
				
				4.服务器代理
				
				5.请求头
			
		缺点：	
			ajax能获取的数据，jsonp不一定能获取到
			
			jsonp能获取到数据，ajax都能处理。
			
			增加了http请求。


### 闭包

    	js的特性；
    	函数套函数，子函数能使用父函数的变量或者参数，而父函数不能使用子函数的变量或者参数。
    	
    	
    	1.形成私有域，避免命名冲突
    	
    	2.当子函数使用父函数的变量或者参数的时候，变量或者参数不会被垃圾回收机制给回收，一直存在父函数中。
			
### window下有name属性，值为空

### cookies，sessionStorage 和 localStorage 的区别？

		cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
		cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
		
		sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

		存储大小：
			cookie数据大小不能超过4k。
			sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

		有期时间：
	    	localStorage      存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
        	sessionStorage    数据在当前浏览器窗口关闭后自动删除。
			cookie            设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
		
### box-sizing

        box-sizing属性可以为三个值之一：content-box（default），border-box，padding-box。
        
        content-box，border和padding不计算入width之内
        
        border-box，border和padding计算入width之内

### 定位

        absolute、relative、fixed的定位原点
		
		absolute{
			有定位父级走父级
			没有走document
		}
		
		
		relative{
			自己
		}
		
		
		fixed{
			跟可视区窗口
		}

### for循环and定时器小例子		
        for(var i=0;i<10;i++){
    		setTimeout(function(){
    			console.log(i);
    		},0);
    	}
        因为每循环一次就开了一个定时器，所以
    		第一：会输出10次；
    		第二：因为定时器是异步的，而for比setTimeout的速度快，
    		setTimeout中的没有i这个变量，那么会往父级找，而这个时候就找到循环完的结果10。
    		
### 事件委托

		事件源的应用，内存性能优化
		ul.onclick = function(ev){
			console.log(ev.target)
			//alert(ev.target.innerHTML)
			ev.target.style.background = 'red';
		}
		
### 事件监听 , 只要问到JQ几乎必考

    	1.事件必须绑定在父级身上
    	
    	2.当触发某个事件的时候，通过事件冒泡，使得父级可以从ev.target中监听到当前触发的元素是否为想要的子级
    	
    	3.如果是就执行事件处理函数。
```
        $('button').click(function(){
    		$('ul').append($('<li>'));
    	});
    	
    //	$('li').click(function(){
    //		$(this).css('background','red');
    //	});
    
    	$('ul').on('click','li',function(){
    		$(this).css('background','red');
    	});
```
### 属性小例子

        如果直接给window下添加属性（包括没有使用var去申明的变量且赋值的），那么是可以被delete清掉。
        
        如果使用var去声明变量的时候，会在window下创建一个同名属性，这个属性不允许被delete清掉。
        
        只要在对象身上查找不到属性，只会是undefined，不可能报错。 
        
        如果没有通过var去声明某个变量并且这个变量没有赋值或者没有挂在某个对象上，去查找这个变量的时候，就报错。

### split
        只有空字符串切割空字符串才会出现空数组。
        
        console.log(''.split(''))  // []
### 原型和原型链

        对象身上没有原型但是有原型链。
        
        函数既有原型也有原型链。
        
        实例化对象的原型链等于构造函数的原型
        
        原型链就是实例化对象与构造函数之间的桥梁。
    
### instanceof

    	运算符：
    		左值(对象)是不是右值(构造函数)构造出来的
		
### constructor 
		
    	构造函数上的一个属性。这个属性指向这个实例化对象的构造函数。
    	
    	不过这个属性非常容易被修改。如果被修改，那么手动的修正constructor的指向。

### hasOwnProperty
		某个属性是不是这个对象下的。
		
		返回值：Boolean
		
		注意：
			属性只有在对象自身上的才为true，原型上都不算。
			
### toString
		
        把别的数据类型转成字符串。
        
        每个内置对象都有toString方法
        
        只要你使用alert，那么alert函数会调用这个类型toString方法.
        
        obj.toSting() -> [object Object]
        
        [object 由什么内置的构造函数构造出来的]
        
        自定义的实例化对象的toString指向Object的toString。（通过原型链查找的）

### 箭头函数

        箭头函数的this默认永远指向定义的父级。
		
		注意：
			事件绑定函数不用使用箭头函数
			
### 类式继承

    	1.属性继承
    	
    		调用父类修正this指向
    		
    		function Drag2(id){
        		Drag.call(this,id);
        	}
        	
    	2.方法继承
    	
    	d2.move -> d2.__proto__ -> Drag2.prototype.move
    	
    	Drag2.prototype = ph -> ph.move -> ph.__proto__
    	
    	-> paohui.prototype.move -> Drag.prototype.move
    	
    	两个对象的赋值为赋址，修改了一个就会改变另一个,反之不会被修改。
    	js有个特性，实例化对象上如果没有查找的方法或者属性，那么会
    	通过该实例化对象的原型上去查找。
    	
    	Drag2.prototype = ph  (他们2个的地址是同一个地址)
    	
    	paohui.prototype = Drag.prototype (他们2个的地址是同一个地址)
    	
    	改变Drag2.prototype是不会影响Drag.prototype（因为他们2个不是同一个地址）
    	
    	但是ph是个实例化对象，ph上没有要继承的方法，会通过原型链
    	找到paohui.prototype，又等于Drag.prototype，而Drag.prototype有要查找的方法，所以可以继承下来

### ajax步骤

        1.创建一个ajax对象
        		
        var ajax = new XMLHttpRequest(); 
        
        2.填写请求地址
        
        	mothod:使用什么方式请求 
        	
        	url:请求的地址
        	
        	boolean：是否异步（默认为true）
        
        ajax.open('get','php/get.php?user='+user.value);
        
        3.发送请求
        
        ajax.send();
        
        4.等待服务器响应

### get和post区别

        post:
			通过send发送前端数据给后端。
			
			相对安全（关于用户的信息会用post或传文件的时候）
			
			体积理论上来说是无限大。（但是后端会做限制）
			
			在send前设置一个setRequestHeader()
			

		get：
			通过浏览器的url来发送数据给后端。
			
			相对来说就不安全（只要不跟用户信息打交道或者在数据一定范围都可以使用get）
			
			体积就受浏览器的限制。（不同浏览器有不同的限制）
			
			不用设置请求头。
			
### URL编码

        在IE浏览器下中文会被解析为URL编码格式，容易出问题，所以建议只要val值会出现中文就用encodeURI()转一下。
        
    	ajax.open('get','php/get.php?user='+encodeURI(user.value));

### XMLHttpRequest

        XMLHttpRequest 对象的三个重要的属性：
		
			1.监听事件
				onreadystatechange
			
			2.执行的步骤
			
				ajax.readyState
			
			3.状态码
				ajax.status
				
### eval
        让字符串能够执行js代码
		
		1.jQuery插件支持的转换方式：
		
			$.parseJSON( jsonstr )
			
			jQuery.parseJSON(jsonstr),可以将json字符串转换成json对象
			
		2.浏览器支持的转换方式(Firefox，chrome，opera，safari，ie9，ie8)等浏览器：
		
			JSON.parse(jsonstr); //可以将json字符串转换成json对象 
			
			JSON.stringify(jsonobj); //可以将json对象转换成json对符串 
			
			注：ie8(兼容模式),ie7和ie6没有JSON对象，推荐采用JSON官方的方式，引入json.js。
			
		3.Javascript支持的转换方式：
		
			eval('(' + jsonstr + ')'); 
			
			可以将json字符串转换成json对象,注意需要在json字符外包裹一对小括号
			
			注：ie8(兼容模式),ie7和ie6也可以使用eval()将字符串转为JSON对象，
			但不推荐这些方式，这种方式不安全eval会执行json串中的表达式。
			
			注：JSON.parse()与eval()的区别
			
			    JSON.parse()之可以解析json格式的数据，
			    
				并且会对要解析的字符串进行格式检查，
				
				如果格式不正确则不进行解析，
				
				而eval()则可以解析任何字符串，eval是不安全的。
				
		4.new function 的方法
		
            var obj = "{'name':123}";
	
	        var data = new Function('','return'+obj)();
	
	        console.log(data);
	        
### ajax上传

        当使用表单上传控件的时候，可以通过表单控件下的
        
		files[0],找到上传的文件资源。
		
		
		new FormData:
		
			FormData对象可以组装一组用 XMLHttpRequest发送请求的键/值对
			
			通过append方法把键值对放到FormData对象中，当send的时候直接传
			
			FormData对象即可。
			
			FormData.append('user','momo');
			FormData.append('pass','12345');
			
			ajax.send(FormData);
			
		
		ajax.upload.onprogress 来监控当前上传的进度
		
		这个事件对象中有
		
		loaded  每次传输的进度
		
		total   总进度
		
### ajax的缺点
			
		1.不支持浏览器回退前进
		
		2.安全问题
			
		
		跨域（跨源）：
			
			跨出一个范围
			
			源:
				同源策略
				
			同源策略（Same origin policy）是一种约定，
			它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，
			则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，
			浏览器只是针对同源策略的一种实现。
			
			同源：
				同域名、同端口、同协议
				
			跨源:
				不同域名 || 不同端口 || 不同协议
				
				域名:
					ip地址的取的别名。
					
				端口:
					指计算机内部或交换机路由器内的端口，不可见。
					
				协议:
					HTTP/HTTPS 网络超文本传输协议   安全网络超文本传输协议
					file：本地协议
					ftp:文件传输协议
		
			
			解决跨域问题：
				
				1.新版本XMLHttpRequest + 后端设置请求头权限
					
					Access-Control-Allow-Origin
					
				2.服务器代理
					
					使用服务器文件，在默认情况下可以直接跨域
					那么只要把这个服务器文件与请求文件同源就可以实现跨域
				
				3.flash
				
				4.iframe
				
				5.jsonp
					json + padding
					
					json格式的数据内填充 （填充式 JSON 或参数式 JSON）

###	call 和 apply的区别
        call 和 apply 都是函数下的一个静态方法，可以通过函数 .call() 或 函数 .apply() 的方式来间接调用该函数，通过 call 或 apply 执行时候的第一个参数改变该函数执行过程中的上下文对象（this），如果第一个参数不存在或者设置成 null/undefined，那么该函数执行过程中的上下文对象指向全局上下文对象，在 JavaScript 中指向了 window 对象。
        
        不同之处在于后续参数上，call 第一个参数以后的参数值将被一一对应的赋值给源函数的形参，而 apply 则是传入一个数组，间接传给函数的 arguments 对象。
